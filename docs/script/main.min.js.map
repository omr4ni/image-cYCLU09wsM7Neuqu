{"version":3,"sources":["webpack://image-stylization-threading/./src/ts/helpers.ts","webpack://image-stylization-threading/./src/ts/main.ts","webpack://image-stylization-threading/./src/ts/parameters.ts","webpack://image-stylization-threading/./src/ts/plotter/compositing.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-base.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-canvas-2d.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-svg.ts","webpack://image-stylization-threading/./src/ts/plotter/xml-writer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-computer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-plotter.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-base.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-monochrome.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-red-green-blue.ts","webpack://image-stylization-threading/./src/ts/threading/transformation.ts","webpack://image-stylization-threading/webpack/bootstrap","webpack://image-stylization-threading/webpack/startup"],"names":["downloadTextFile","content","filename","fileType","blob","Blob","type","window","navigator","msSaveBlob","URL","createObjectURL","linkElement","document","createElement","download","href","dataset","downloadurl","style","display","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","getQueryStringValue","name","url","location","queryStringStart","indexOf","queryString","substring","length","split","keyValue","decodeURIComponent","declarePolyfills","Array","prototype","includes","console","log","Object","defineProperty","value","element","this","String","repeat","count","Infinity","RangeError","result","i","Helpers","canvasPlotter","PlotterCanvas2D","threadPlotter","threadComputer","needToReset","mainLoop","reset","Parameters","linesOpacity","linesThickness","computeNextSegments","showIndicators","updateIndicators","Page","Canvas","setIndicatorText","plot","debug","drawDebugView","context","requestAnimationFrame","updateBlur","blur","onNewImage","image","showLoader","ThreadComputer","ThreadPlotter","addRedrawObserver","addResetObserver","addBlurChangeObserver","addFileUploadObserver","defaultImage","Image","addEventListener","src","addDownloadObserver","svgPlotter","PlotterSVG","svgString","export","addDownloadInstructionsObserver","text","instructions","main","EShape","EMode","controlId","redrawObservers","triggerRedraw","observer","resetObservers","triggerReset","Tabs","addObserver","Range","addLazyObserver","Checkbox","Observers","canvasResize","push","isInDebug","updateIndicatorsVisibility","shouldBeVisible","isChecked","setIndicatorsVisibility","setIndicatorVisibility","callback","FileControl","addUploadObserver","filesList","FileReader","onload","readAsDataURL","getValues","getValue","raw","Math","pow","updateDownloadInstructionsVisibility","isMonochrome","mode","MONOCHROME","isBlackOnWhite","invertColors","Controls","setVisibility","ECompositingOperation","EColor","supportsAdvancedCompositing","computeRawColor","color","r","g","b","RED","GREEN","BLUE","resetCanvasCompositing","globalCompositeOperation","useAdvancedCompositing","applyCanvasCompositing","opacity","operation","rawRGB","targetOperation","LIGHTEN","ceil","strokeStyle","Demopage","setErrorMessage","DARKEN","drawBrokenLine","points","thickness","lines","from","to","drawLines","PlotterBase","canvas","getCanvas","getContext","alpha","cssPixel","devicePixelRatio","resize","actualWidth","floor","clientWidth","actualHeight","clientHeight","width","height","initialize","infos","fillStyle","backgroundColor","lineJoin","fillRect","finalize","filter","lineWidth","line","beginPath","moveTo","x","y","lineTo","stroke","closePath","drawPoints","diameter","point","arc","PI","fill","writer","XMLWriter","hasBlur","addLine","startBlock","endBlock","strokeColor","toFixed","start","Date","now","indentationLevel","join","prefix","MIN_SAFE_NUMBER","TWO_PI","clamp","min","max","mix","a","randomItem","list","random","hiddenCanvasData","sourceImage","hiddenCanvas","hiddenCanvasContext","drawThread","plotter","nbSegmentsToIgnore","transformation","computeTransformation","size","scaling","hiddenCanvasScale","lineThickness","compositing","thread","iterateOnThreads","peg","transform","lineOpacity","drawPegs","pointSize","pegs","targetContext","drawImage","maxMillisecondsTaken","performance","targetNbSegments","nbLines","nbSegments","lowerNbSegments","resetHiddenCanvas","lineOpacityInternal","iPeg","drawSegmentOnHiddenCanvas","computeError","lastColor","threadToGrow","getThreadToGrow","enableSamplingFor","computeSegment","linethickness","quality","ThreadMonochrome","ThreadRedBlueGreen","computePegs","updateFunction","toString","error","average","meanSquare","variance","totalNbSegments","domainWidth","domainHeight","threadThickness","namedPegs","iP","namedThread","initializeHiddenCanvasLineProperties","theoricalThicknes","lastPeg","nextPeg","startingSegment","computeBestStartingSegment","peg1","peg2","HISTORY_SIZE","prevousPegs","slice","computeBestNextPeg","wantedSize","computeBestSize","imageData","getImageData","adjustCanvasData","data","putImageData","uploadCanvasDataToCPU","nbPixels","nbSamples","errorRed","errorGreen","errorBlue","round","distancetoError","targetSize","Transformation","candidates","bestScore","step","iPegId1","iPegId2","arePegsTooClose","candidateScore","computeSegmentPotential","currentPeg","pegsToAvoid","p1","p2","dX","dY","potential","segmentLength","sqrt","iSample","sample","sampleCanvasData","coords","minX","maxX","minY","maxY","topLeft","sampleCanvasPixel","topRight","bottomLeft","bottomRight","fractX","top","bottom","pixelX","pixelY","index","sampleCanvas","sourceImageSize","maxSize","sizingFactor","domainSize","DEFAULT_CANVAS_SIZE_FOR_PEGS","aspectRatio","pegsShape","shape","pegsSpacing","RECTANGLE","nbPegsPerWidth","nbPegsPerHeight","iW","iH","absDeltaAngle","abs","angle","nbPegs","baseDeltaAngle","cos","sin","nbSegmentsDrawn","plotterInfos","displayPegs","lowerNbSegmentsForThread","targetNumber","computeNbSegments","iterateOnThread","fromSegmentNumber","ThreadBase","threadPegs","blackBackground","computeAdjustedValue","rawValue","adjustedValue","threadPegsRed","threadPegsGreen","threadPegsBlue","repartition","computeIdealSegmentsRepartition","red","green","blue","cumulatedRed","cumulatedGreen","cumulatedBlue","totalColor","frequencyRed","frequencyGreen","frequencyBlue","channel","idealRed","idealGreen","idealBlue","gapRed","gapGreen","gapBlue","frameSize","elementSize","scaleToFitWidth","scaleToFitHeight","origin","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call"],"mappings":"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","file":"main.min.js","sourcesContent":["function downloadTextFile(content: string, filename: string): void {\r\n    const fileType = \"text/plain\";\r\n\r\n    const blob = new Blob([content], { type: fileType });\r\n\r\n    if (typeof window.navigator !== \"undefined\" && typeof window.navigator.msSaveBlob !== \"undefined\") { // for IE\r\n        window.navigator.msSaveBlob(blob, filename);\r\n    } else {\r\n        const objectUrl = URL.createObjectURL(blob);\r\n\r\n        const linkElement = document.createElement('a');\r\n        linkElement.download = filename;\r\n        linkElement.href = objectUrl;\r\n        linkElement.dataset.downloadurl = `${fileType}:${linkElement.download}:${linkElement.href}`;\r\n        linkElement.style.display = \"none\";\r\n        document.body.appendChild(linkElement);\r\n        linkElement.click();\r\n        document.body.removeChild(linkElement);\r\n\r\n        // don't forget to free the objectURL after a few seconds\r\n        setTimeout(() => {\r\n            URL.revokeObjectURL(objectUrl);\r\n        }, 5000);\r\n    }\r\n}\r\n\r\nfunction getQueryStringValue(name: string): string | null {\r\n    const url = window.location.href;\r\n    const queryStringStart = url.indexOf(\"?\");\r\n    if (queryStringStart >= 0) {\r\n        const queryString = url.substring(queryStringStart + 1);\r\n        if (queryString.length > 0) {\r\n            const parameters = queryString.split(\"&\");\r\n            for (const parameter of parameters) {\r\n                const keyValue = parameter.split(\"=\");\r\n                if (keyValue.length === 2) {\r\n                    const decodedKey = decodeURIComponent(keyValue[0]);\r\n                    if (decodedKey === name) {\r\n                        return decodeURIComponent(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction declareArrayIncludesPolyfill(): void {\r\n    if (typeof Array.prototype.includes !== \"function\") {\r\n        console.log(\"Declaring Array.includes polyfill...\");\r\n        Object.defineProperty(Array.prototype, \"includes\", {\r\n            value<T>(this: T[], element: any): boolean {\r\n                return this.indexOf(element) >= 0;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction declareStringRepeatPolyfill(): void {\r\n    if (typeof String.prototype.repeat !== \"function\") {\r\n        console.log(\"Declaring String.repeat polyfill...\");\r\n        Object.defineProperty(String.prototype, \"repeat\", {\r\n            value(this: string, count: number): string {\r\n                if (count < 0 || count === Infinity) {\r\n                    throw new RangeError();\r\n                }\r\n\r\n                let result = \"\";\r\n                for (let i = 0; i < count; i++) {\r\n                    result += this;\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction declarePolyfills(): void {\r\n    declareArrayIncludesPolyfill();\r\n    declareStringRepeatPolyfill();\r\n}\r\n\r\nexport {\r\n    declarePolyfills,\r\n    downloadTextFile,\r\n    getQueryStringValue,\r\n};\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport { Parameters } from \"./parameters\";\r\n\r\nimport { PlotterCanvas2D } from \"./plotter/plotter-canvas-2d\";\r\nimport { PlotterSVG } from \"./plotter/plotter-svg\";\r\n\r\nimport { ThreadComputer } from \"./threading/thread-computer\";\r\nimport { ThreadPlotter } from \"./threading/thread-plotter\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction main(): void {\r\n    const MAX_COMPUTING_TIME_PER_FRAME = 20; // ms\r\n    const canvasPlotter = new PlotterCanvas2D();\r\n    let threadPlotter: ThreadPlotter = null;\r\n    let threadComputer: ThreadComputer = null;\r\n    let needToReset = true;\r\n\r\n    Parameters.addRedrawObserver(() => { threadPlotter?.reset(); });\r\n    Parameters.addResetObserver(() => { needToReset = true; });\r\n\r\n    function mainLoop(): void {\r\n        if (needToReset) {\r\n            threadComputer.reset(Parameters.linesOpacity, Parameters.linesThickness);\r\n            threadPlotter.reset()\r\n            needToReset = false;\r\n        }\r\n\r\n        const computedSomething = threadComputer.computeNextSegments(MAX_COMPUTING_TIME_PER_FRAME);\r\n\r\n        if (computedSomething && Parameters.showIndicators) {\r\n            threadComputer.updateIndicators(Page.Canvas.setIndicatorText);\r\n        }\r\n\r\n        threadPlotter.plot();\r\n\r\n        if (Parameters.debug) {\r\n            threadComputer.drawDebugView(canvasPlotter.context);\r\n        }\r\n\r\n        requestAnimationFrame(mainLoop);\r\n    }\r\n\r\n    function updateBlur(blur: number): void {\r\n        canvasPlotter.blur = blur;\r\n    }\r\n    Parameters.addBlurChangeObserver(updateBlur);\r\n    updateBlur(Parameters.blur);\r\n\r\n    function onNewImage(image: HTMLImageElement): void {\r\n        Page.Canvas.showLoader(false);\r\n        threadComputer = new ThreadComputer(image);\r\n        threadPlotter = new ThreadPlotter(canvasPlotter, threadComputer);\r\n        needToReset = true;\r\n    }\r\n    Parameters.addFileUploadObserver(onNewImage);\r\n\r\n    Page.Canvas.showLoader(true);\r\n    const defaultImage = new Image();\r\n    defaultImage.addEventListener(\"load\", () => {\r\n        onNewImage(defaultImage);\r\n        requestAnimationFrame(mainLoop);\r\n    });\r\n    defaultImage.src = \"./resources/cat.jpg\";\r\n\r\n    Parameters.addDownloadObserver(() => {\r\n        const svgPlotter = new PlotterSVG();\r\n        const plotter = new ThreadPlotter(svgPlotter, threadComputer);\r\n        plotter.plot();\r\n        const svgString = svgPlotter.export();\r\n        const filename = \"image-as-threading.svg\";\r\n        Helpers.downloadTextFile(svgString, filename);\r\n    });\r\n\r\n    Parameters.addDownloadInstructionsObserver(() => {\r\n        const text = threadComputer.instructions;\r\n        const filename = \"image-as-threading_instructions.txt\";\r\n        Helpers.downloadTextFile(text, filename);\r\n    });\r\n}\r\n\r\nHelpers.declarePolyfills();\r\nmain();\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nconst controlId = {\r\n    UPLOAD_INPUT_IMAGE: \"input-image-upload-button\",\r\n    SHAPE: \"shape-tabs-id\",\r\n    PEGS_DENSITY: \"pegs-range-id\",\r\n    NB_LINES: \"lines-range-id\",\r\n    QUALITY: \"quality-tabs-id\",\r\n    MODE: \"thread-mode-tabs-id\",\r\n    LINES_OPACITY: \"opacity-range-id\",\r\n    LINES_THICKNESS: \"thickness-range-id\",\r\n    DISPLAY_PEGS: \"display-pegs-checkbox-id\",\r\n    INVERT_COLORS: \"invert-colors-checkbox-id\",\r\n    SHOW_INDICATORS: \"show-indicators-checkbox-id\",\r\n    BLUR: \"blur-range-id\",\r\n    DOWNLOAD: \"result-download-id\",\r\n    DOWNLOAD_INSTRUCTIONS: \"instructions-download-id\",\r\n};\r\n\r\nenum EShape {\r\n    RECTANGLE = \"0\",\r\n    ELLIPSIS = \"1\",\r\n}\r\n\r\nenum EMode {\r\n    MONOCHROME = \"0\",\r\n    COLORS = \"1\",\r\n}\r\n\r\ntype Observer = () => unknown;\r\nconst redrawObservers: Observer[] = [];\r\nfunction triggerRedraw(): void {\r\n    for (const observer of redrawObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nconst resetObservers: Observer[] = [];\r\nfunction triggerReset(): void {\r\n    for (const observer of resetObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nPage.Tabs.addObserver(controlId.SHAPE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.PEGS_DENSITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.QUALITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.MODE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_OPACITY, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_THICKNESS, triggerReset);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_PEGS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, triggerReset);\r\nPage.Canvas.Observers.canvasResize.push(triggerRedraw);\r\n\r\nconst isInDebug = Helpers.getQueryStringValue(\"debug\") === \"1\";\r\n\r\nPage.Canvas.setIndicatorVisibility(\"error-average\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-mean-square\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-variance\", isInDebug);\r\n\r\nfunction updateIndicatorsVisibility(): void {\r\n    const shouldBeVisible = Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    Page.Canvas.setIndicatorsVisibility(shouldBeVisible);\r\n}\r\nPage.Checkbox.addObserver(controlId.SHOW_INDICATORS, updateIndicatorsVisibility);\r\nupdateIndicatorsVisibility();\r\n\r\nabstract class Parameters {\r\n    public static addFileUploadObserver(callback: (image: HTMLImageElement) => unknown): void {\r\n        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, (filesList: FileList) => {\r\n            if (filesList.length === 1) {\r\n                Page.Canvas.showLoader(true);\r\n                const reader = new FileReader();\r\n                reader.onload = () => {\r\n                    const image = new Image();\r\n                    image.addEventListener(\"load\", () => {\r\n                        callback(image);\r\n                    })\r\n                    image.src = reader.result as string;\r\n                };\r\n                reader.readAsDataURL(filesList[0]);\r\n            }\r\n        });\r\n    }\r\n\r\n    public static get debug(): boolean {\r\n        return isInDebug;\r\n    }\r\n\r\n    public static get shape(): EShape {\r\n        return Page.Tabs.getValues(controlId.SHAPE)[0] as EShape;\r\n    }\r\n\r\n    public static get pegsSpacing(): number {\r\n        return 1.1 - Page.Range.getValue(controlId.PEGS_DENSITY);\r\n    }\r\n\r\n    public static get quality(): number {\r\n        return +Page.Tabs.getValues(controlId.QUALITY)[0];\r\n    }\r\n\r\n    public static get mode(): EMode {\r\n        return Page.Tabs.getValues(controlId.MODE)[0] as EMode;\r\n    }\r\n\r\n    public static get nbLines(): number {\r\n        return Page.Range.getValue(controlId.NB_LINES);\r\n    }\r\n\r\n    public static get linesOpacity(): number {\r\n        const raw = Page.Range.getValue(controlId.LINES_OPACITY);\r\n        return Math.pow(2, raw - 7); // 2^(raw+2) / 256\r\n    }\r\n\r\n    public static get linesThickness(): number {\r\n        return Page.Range.getValue(controlId.LINES_THICKNESS);\r\n    }\r\n\r\n    public static get displayPegs(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.DISPLAY_PEGS);\r\n    }\r\n\r\n    public static get invertColors(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.INVERT_COLORS);\r\n    }\r\n\r\n    public static get showIndicators(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    }\r\n\r\n    public static addRedrawObserver(callback: Observer): void {\r\n        redrawObservers.push(callback);\r\n    }\r\n\r\n    public static addResetObserver(callback: Observer): void {\r\n        resetObservers.push(callback);\r\n    }\r\n\r\n    public static get blur(): number {\r\n        return Page.Range.getValue(controlId.BLUR);\r\n    }\r\n    public static addBlurChangeObserver(callback: (newBlur: number) => unknown): void {\r\n        Page.Range.addObserver(controlId.BLUR, callback);\r\n    }\r\n\r\n    public static addDownloadObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);\r\n    }\r\n\r\n    public static addDownloadInstructionsObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD_INSTRUCTIONS, callback);\r\n    }\r\n}\r\n\r\nfunction updateDownloadInstructionsVisibility(): void {\r\n    const isMonochrome = (Parameters.mode === EMode.MONOCHROME);\r\n    const isBlackOnWhite = !Parameters.invertColors;\r\n    Page.Controls.setVisibility(controlId.DOWNLOAD_INSTRUCTIONS, isMonochrome && isBlackOnWhite);\r\n}\r\nPage.Tabs.addObserver(controlId.MODE, updateDownloadInstructionsVisibility);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, updateDownloadInstructionsVisibility);\r\nupdateDownloadInstructionsVisibility();\r\n\r\nexport {\r\n    Parameters,\r\n    EMode,\r\n    EShape,\r\n};\r\n","import \"../page-interface-generated\";\r\n\r\nenum ECompositingOperation {\r\n    DARKEN,\r\n    LIGHTEN,\r\n}\r\n\r\nenum EColor {\r\n    MONOCHROME,\r\n    RED,\r\n    GREEN,\r\n    BLUE,\r\n}\r\n\r\ninterface IColor {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n}\r\n\r\nlet supportsAdvancedCompositing = true;\r\nfunction useAdvancedCompositing(): boolean {\r\n    return supportsAdvancedCompositing;\r\n}\r\n\r\nfunction computeRawColor(color: EColor): IColor {\r\n    if (color === EColor.MONOCHROME) {\r\n        return { r: 1, g: 1, b: 1 };\r\n    }\r\n\r\n    const result: IColor = {\r\n        r: (color === EColor.RED) ? 1 : 0,\r\n        g: (color === EColor.GREEN) ? 1 : 0,\r\n        b: (color === EColor.BLUE) ? 1 : 0,\r\n    };\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @param opacity in [0, 1]\r\n */\r\nfunction applyCanvasCompositing(context: CanvasRenderingContext2D, color: EColor, opacity: number, operation: ECompositingOperation): void {\r\n    const rawRGB = computeRawColor(color);\r\n\r\n    if (supportsAdvancedCompositing) {\r\n        const targetOperation = (operation === ECompositingOperation.LIGHTEN) ? \"lighter\" : \"difference\";\r\n        context.globalCompositeOperation = targetOperation;\r\n        if (context.globalCompositeOperation === targetOperation) {\r\n            const value = Math.ceil(255 * opacity);\r\n            context.strokeStyle = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            return; // success\r\n        } else {\r\n            supportsAdvancedCompositing = false;\r\n            Page.Demopage.setErrorMessage(\"advanced-compositing-not-supported\", `Your browser does not support canvas2D compositing '${targetOperation}'. The project will not run as expected.`);\r\n        }\r\n    }\r\n\r\n    // basic compositing\r\n    {\r\n        resetCanvasCompositing(context);\r\n        if (operation === ECompositingOperation.DARKEN) {\r\n            rawRGB.r = 1 - rawRGB.r;\r\n            rawRGB.g = 1 - rawRGB.g;\r\n            rawRGB.b = 1 - rawRGB.b;\r\n        }\r\n        context.strokeStyle = `rgba(${rawRGB.r * 255}, ${rawRGB.g * 255}, ${rawRGB.b * 255}, ${opacity})`;\r\n    }\r\n}\r\n\r\nfunction resetCanvasCompositing(context: CanvasRenderingContext2D): void {\r\n    context.globalCompositeOperation = \"source-over\";\r\n}\r\n\r\nexport {\r\n    EColor,\r\n    ECompositingOperation,\r\n    applyCanvasCompositing,\r\n    computeRawColor,\r\n    resetCanvasCompositing,\r\n    useAdvancedCompositing,\r\n};\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EColor, ECompositingOperation } from \"./compositing\";\r\n\r\ninterface IPlotterInfo {\r\n    backgroundColor: string;\r\n    blur: number;\r\n}\r\n\r\ninterface IImageFitting {\r\n    sizeInPlotter: ISize;\r\n    imageRelativeToCanvasPixel: (relativeCoords: IPoint) => IPoint;\r\n};\r\n\r\nabstract class PlotterBase {\r\n    public abstract resize(): void;\r\n    public abstract initialize(infos: IPlotterInfo): void;\r\n    public abstract finalize(): void;\r\n\r\n    public abstract drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void;\r\n    public abstract drawPoints(points: IPoint[], color: string, diameter: number): void;\r\n\r\n    public abstract get size(): ISize;\r\n\r\n    public drawBrokenLine(points: IPoint[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        const lines: ILine[] = [];\r\n\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            lines.push({ from: points[i], to: points[i + 1] });\r\n        }\r\n        this.drawLines(lines, color, opacity, operation, thickness);\r\n    }\r\n}\r\n\r\nexport { PlotterBase, IImageFitting, IPlotterInfo, ISize }\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"./compositing\";\r\nimport { IPlotterInfo, PlotterBase } from \"./plotter-base\";\r\n\r\nimport \"../page-interface-generated\";\r\n\r\nclass PlotterCanvas2D extends PlotterBase {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    public readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    public constructor() {\r\n        super();\r\n\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\", { alpha: false });\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n    }\r\n\r\n    public resize(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n        }\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.context.fillStyle = infos.backgroundColor;\r\n        this.context.lineJoin = \"round\";\r\n        resetCanvasCompositing(this.context);\r\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void { }\r\n\r\n    public set blur(value: number) {\r\n        if (value === 0) {\r\n            this.canvas.style.filter = \"\";\r\n        } else {\r\n            this.canvas.style.filter = `blur(${value}px)`; // simple blur supported everywhere but with artifacts on the edges\r\n            // artifact-free blur, but not supported everywhere\r\n            this.canvas.style.filter = `url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a' x='0' y='0' width='1' height='1'%3E%3CfeGaussianBlur stdDeviation='${value}' result='b'/%3E%3CfeMorphology operator='dilate' radius='${value}'/%3E %3CfeMerge%3E%3CfeMergeNode/%3E%3CfeMergeNode in='b'/%3E%3C/feMerge%3E%3C/filter%3E%3C/svg%3E#a\")`;\r\n        }\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n            applyCanvasCompositing(this.context, color, opacity, operation);\r\n\r\n            this.context.lineWidth = thickness * this.cssPixel;\r\n\r\n            for (const line of lines) {\r\n                this.context.beginPath();\r\n                this.context.moveTo(line.from.x * this.cssPixel, line.from.y * this.cssPixel);\r\n                this.context.lineTo(line.to.x * this.cssPixel, line.to.y * this.cssPixel);\r\n                this.context.stroke();\r\n                this.context.closePath();\r\n            }\r\n\r\n            resetCanvasCompositing(this.context);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.context.fillStyle = color;\r\n            this.context.strokeStyle = \"none\";\r\n\r\n            for (const point of points) {\r\n                this.context.beginPath();\r\n                this.context.arc(point.x * this.cssPixel, point.y * this.cssPixel, 0.5 * diameter * this.cssPixel, 0, 2 * Math.PI);\r\n                this.context.fill();\r\n                this.context.closePath();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: Math.floor(this.canvas.width / this.cssPixel),\r\n            height: Math.floor(this.canvas.height / this.cssPixel),\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterCanvas2D };\r\n\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { computeRawColor, EColor, ECompositingOperation, useAdvancedCompositing } from \"./compositing\";\r\nimport { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\nimport { XMLWriter } from \"./xml-writer\";\r\n\r\nconst WIDTH = 1000;\r\nconst HEIGHT = 1000;\r\n\r\nconst BLUR_EFFECT_ID = \"gaussianBlur\";\r\n\r\nclass PlotterSVG extends PlotterBase {\r\n    private hasBlur: boolean;\r\n    private writer: XMLWriter;\r\n\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public resize(): void {\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.writer = new XMLWriter();\r\n\r\n        this.hasBlur = infos.blur > 0;\r\n\r\n        this.writer.addLine(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>`);\r\n        this.writer.startBlock(`<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${WIDTH} ${HEIGHT}\">`);\r\n\r\n        if (this.hasBlur) {\r\n            this.writer.startBlock(`<defs>`);\r\n            this.writer.startBlock(`<filter id=\"${BLUR_EFFECT_ID}\" x=\"0\" y=\"0\">`);\r\n            this.writer.addLine(`<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${infos.blur}\"/>`);\r\n            this.writer.endBlock(`</filter>`);\r\n            this.writer.endBlock(`</defs>`);\r\n\r\n            this.writer.startBlock(`<g filter=\"url(#${BLUR_EFFECT_ID})\">`);\r\n\r\n        }\r\n\r\n        const margin = 10;\r\n        this.writer.addLine(`<rect fill=\"white\" stroke=\"none\" x=\"${-margin}\" y=\"${-margin}\" width=\"${WIDTH + 2 * margin}\" height=\"${HEIGHT + 2 * margin}\"/>`);\r\n    }\r\n\r\n    public finalize(): void {\r\n        if (this.hasBlur) {\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n        this.writer.endBlock(`</svg>`);\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n\r\n            let strokeColor: string;\r\n            if (useAdvancedCompositing()) {\r\n                this.writer.startBlock(`<defs>`);\r\n                this.writer.startBlock(`<style type=\"text/css\">`);\r\n                this.writer.startBlock(`<![CDATA[`);\r\n                this.writer.addLine(`line { mix-blend-mode: difference; }`);\r\n                if (operation === ECompositingOperation.LIGHTEN) {\r\n                    this.writer.addLine(`svg { filter: invert(1); background: black; }`);\r\n                }\r\n                this.writer.endBlock(`]]>`);\r\n                this.writer.endBlock(`</style>`);\r\n                this.writer.endBlock(`</defs>`);\r\n\r\n                const value = Math.ceil(255 * opacity);\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            } else {\r\n                const value = (useAdvancedCompositing()) ? 255 : 0;\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgba(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value}, ${opacity})`;\r\n            }\r\n\r\n            // lines container\r\n            this.writer.startBlock(`<g stroke=\"${strokeColor}\" stroke-width=\"${thickness}\" stroke-linecap=\"round\" fill=\"none\">`);\r\n            for (const line of lines) {\r\n                this.writer.addLine(`<line x1=\"${line.from.x.toFixed(1)}\" y1=\"${line.from.y.toFixed(1)}\" x2=\"${line.to.x.toFixed(1)}\" y2=\"${line.to.y.toFixed(1)}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.writer.startBlock(`<g fill=\"${color}\" stroke=\"none\">`);\r\n            for (const point of points) {\r\n                this.writer.addLine(`<circle cx=\"${point.x.toFixed(1)}\" cy=\"${point.y.toFixed(1)}\" r=\"${0.5 * diameter}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public export(): string {\r\n        const start = Date.now();\r\n        const result = this.writer.result;\r\n        console.log(`Concatenation took ${Date.now() - start} ms.`);\r\n        return result;\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: WIDTH,\r\n            height: HEIGHT,\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterSVG }\r\n","class XMLWriter {\r\n    private indentationLevel: number = 0;\r\n    private lines: string[] = [];\r\n\r\n    public get result(): string {\r\n        return this.lines.join(\"\\n\");\r\n    }\r\n\r\n    public startBlock(line: string): void {\r\n        this.addLine(line);\r\n        this.indentationLevel++;\r\n    }\r\n\r\n    public endBlock(line: string): void {\r\n        this.indentationLevel--;\r\n        this.addLine(line);\r\n    }\r\n\r\n    public addLine(line: string): void {\r\n        this.lines.push(this.prefix + line);\r\n    }\r\n\r\n    private get prefix(): string {\r\n        return \"\\t\".repeat(this.indentationLevel);\r\n    }\r\n}\r\n\r\nexport { XMLWriter };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EMode, EShape, Parameters } from \"../parameters\";\r\nimport { PlotterBase } from \"../plotter/plotter-base\";\r\nimport { Transformation } from \"./transformation\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"../plotter/compositing\";\r\n\r\nimport { ThreadMonochrome } from \"./thread/thread-monochrome\";\r\nimport { ThreadRedBlueGreen } from \"./thread/thread-red-green-blue\";\r\nimport { ThreadBase } from \"./thread/thread-base\";\r\n\r\nconst MIN_SAFE_NUMBER = -9007199254740991;\r\nconst TWO_PI = 2 * Math.PI;\r\n\r\nfunction clamp(x: number, min: number, max: number): number {\r\n    if (x < min) {\r\n        return min;\r\n    } else if (x > max) {\r\n        return max;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mix(a: number, b: number, x: number): number {\r\n    return a * (1 - x) + b * x;\r\n}\r\n\r\nfunction distance(p1: IPoint, p2: IPoint): number {\r\n    const dX = p1.x - p2.x;\r\n    const dY = p1.y - p2.y;\r\n    return Math.sqrt(dX * dX + dY * dY);\r\n}\r\n\r\nfunction randomItem<T>(list: T[]): T {\r\n    if (list.length === 0) {\r\n        return null;\r\n    }\r\n    const randomIndex = Math.floor(Math.random() * list.length);\r\n    return list[randomIndex];\r\n}\r\n\r\ninterface IPeg {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface ISegment {\r\n    peg1: IPeg;\r\n    peg2: IPeg;\r\n}\r\n\r\ninterface IErrorMeasure {\r\n    average: number;\r\n    variance: number;\r\n    meanSquare: number;\r\n}\r\n\r\ntype IndicatorUpdateFunction = (indicatorId: string, indicatorValue: string) => unknown;\r\n\r\n/**\r\n * Class used to compute which thread path is the best choice.\r\n */\r\nclass ThreadComputer {\r\n    private readonly sourceImage: HTMLImageElement;\r\n    private readonly hiddenCanvas: HTMLCanvasElement;\r\n    private readonly hiddenCanvasContext: CanvasRenderingContext2D;\r\n    private hiddenCanvasData: ImageData = null\r\n    private hiddenCanvasScale: number;\r\n\r\n    private error: IErrorMeasure;\r\n\r\n    private pegs: IPeg[];\r\n\r\n    private lineOpacity: number; // in the final result\r\n    private lineOpacityInternal: number;\r\n    private lineThickness: number; // abstract unit\r\n\r\n    private thread: ThreadBase;\r\n\r\n    private arePegsTooClose: (peg1: IPeg, peg2: IPeg) => boolean;\r\n\r\n    public constructor(image: HTMLImageElement) {\r\n        this.sourceImage = image;\r\n\r\n        this.hiddenCanvas = document.createElement(\"canvas\");\r\n        this.hiddenCanvasContext = this.hiddenCanvas.getContext(\"2d\");\r\n\r\n        this.reset(16 / 256, 1);\r\n    }\r\n\r\n    public drawThread(plotter: PlotterBase, nbSegmentsToIgnore: number): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const lineWidth = (transformation.scaling * this.hiddenCanvasScale) * this.lineThickness;\r\n        const compositing = Parameters.invertColors ? ECompositingOperation.LIGHTEN : ECompositingOperation.DARKEN;\r\n\r\n        this.thread.iterateOnThreads(nbSegmentsToIgnore, (thread: IPeg[], color: EColor) => {\r\n            const points: IPoint[] = [];\r\n            for (const peg of thread) {\r\n                points.push(transformation.transform(peg));\r\n            }\r\n\r\n            plotter.drawBrokenLine(points, color, this.lineOpacity, compositing, lineWidth);\r\n        });\r\n    }\r\n\r\n    public drawPegs(plotter: PlotterBase): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const pointSize = 0.5 * (transformation.scaling * this.hiddenCanvasScale);\r\n\r\n        const points: IPoint[] = [];\r\n        for (const peg of this.pegs) {\r\n            points.push(transformation.transform(peg));\r\n        }\r\n\r\n        plotter.drawPoints(points, \"red\", pointSize);\r\n    }\r\n\r\n    public drawDebugView(targetContext: CanvasRenderingContext2D): void {\r\n        targetContext.drawImage(this.hiddenCanvas, 0, 0, this.hiddenCanvas.width, this.hiddenCanvas.height);\r\n    }\r\n\r\n    /** Returns true if there is nothing more to compute */\r\n    public computeNextSegments(maxMillisecondsTaken: number): boolean {\r\n        const start = performance.now();\r\n\r\n        const targetNbSegments = Parameters.nbLines;\r\n        if (this.nbSegments === targetNbSegments) {\r\n            // no new segment to compute\r\n            return false;\r\n        } else if (this.nbSegments > targetNbSegments) {\r\n            // we drew too many lines already, removes the excess\r\n            this.thread.lowerNbSegments(targetNbSegments);\r\n\r\n            // redraw the hidden canvas from scratch\r\n            this.resetHiddenCanvas();\r\n            this.thread.iterateOnThreads(0, (thread: IPeg[], color: EColor) => {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n\r\n                for (let iPeg = 0; iPeg + 1 < thread.length; iPeg++) {\r\n                    this.drawSegmentOnHiddenCanvas(thread[iPeg], thread[iPeg + 1]);\r\n                }\r\n            });\r\n\r\n            this.computeError();\r\n            return true;\r\n        }\r\n\r\n        let lastColor: EColor = null;\r\n        while (this.nbSegments < targetNbSegments && performance.now() - start < maxMillisecondsTaken) {\r\n            const threadToGrow = this.thread.getThreadToGrow();\r\n\r\n            if (lastColor !== threadToGrow.color) {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, threadToGrow.color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n                this.thread.enableSamplingFor(threadToGrow.color);\r\n                lastColor = threadToGrow.color;\r\n            }\r\n            this.computeSegment(threadToGrow.thread);\r\n\r\n            if (this.nbSegments % 100 === 0) {\r\n                this.computeError();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param opacity in [0,1]\r\n     * @returns true if at least one parameter changed\r\n     */\r\n    public reset(opacity: number, linethickness: number): void {\r\n        this.lineOpacity = opacity;\r\n        this.lineThickness = linethickness;\r\n\r\n        this.hiddenCanvasScale = Parameters.quality;\r\n\r\n        if (Parameters.mode === EMode.MONOCHROME) {\r\n            this.thread = new ThreadMonochrome();\r\n        } else {\r\n            this.thread = new ThreadRedBlueGreen();\r\n        }\r\n        this.resetHiddenCanvas();\r\n\r\n        this.pegs = this.computePegs();\r\n    }\r\n\r\n    public updateIndicators(updateFunction: IndicatorUpdateFunction): void {\r\n        updateFunction(\"pegs-count\", this.pegs.length.toString());\r\n        updateFunction(\"segments-count\", this.nbSegments.toString());\r\n        updateFunction(\"error-average\", this.error.average.toString());\r\n        updateFunction(\"error-mean-square\", this.error.meanSquare.toString());\r\n        updateFunction(\"error-variance\", this.error.variance.toString());\r\n    }\r\n\r\n    public get nbSegments(): number {\r\n        return this.thread.totalNbSegments;\r\n    }\r\n\r\n    public get instructions(): string {\r\n        if (Parameters.mode !== EMode.MONOCHROME) {\r\n            return \"Instructions are only available for monochrome mode.\";\r\n        }\r\n        if (Parameters.invertColors) {\r\n            return \"Instructions are only available for black thread.\";\r\n        }\r\n\r\n        let domainWidth = -1;\r\n        let domainHeight = -1;\r\n        for (const peg of this.pegs) {\r\n            if (domainWidth < peg.x) {\r\n                domainWidth = peg.x;\r\n            }\r\n            if (domainHeight < peg.y) {\r\n                domainHeight = peg.y;\r\n            }\r\n        }\r\n\r\n        const instructions: string[] = [];\r\n        instructions.push(\"Generated by https://piellardj.github.io/image-stylization-threading.\\n\");\r\n        instructions.push(\"Here are instructions to reproduce this in real life. For the best result, make sure you used the website at the highest quality mode and the highest thread opacity.\\n\");\r\n\r\n        instructions.push(`Space units used below are abstract, just scale it to whatever size you want. Typically, you can choose 1 unit = 1 millimeter.`);\r\n        instructions.push(`Computed for a total size of ${domainWidth}x${domainHeight}.`);\r\n        const threadThickness = this.lineThickness * this.hiddenCanvasScale;\r\n        instructions.push(`Computed for a black thread of width ${threadThickness} and opacity ${this.lineOpacity} (this is equivalent to an opaque thread of width ${threadThickness * this.lineOpacity}).`);\r\n\r\n        instructions.push(\"\\nFirst here are the positions of the pegs:\");\r\n\r\n        interface INamedPeg extends IPeg {\r\n            name: string;\r\n        }\r\n\r\n        const namedPegs = this.pegs as INamedPeg[];\r\n        for (let iP = 0; iP < namedPegs.length; iP++) {\r\n            namedPegs[iP].name = `PEG_${iP}`;\r\n            instructions.push(`  - ${namedPegs[iP].name}: x=${namedPegs[iP].x.toFixed(2)} ; y=${namedPegs[iP].y.toFixed(2)}`);\r\n        }\r\n\r\n        instructions.push(\"\\nThen here are the steps of the thread:\");\r\n\r\n        this.thread.iterateOnThreads(0, (thread: IPeg[]) => {\r\n            const namedThread = thread as INamedPeg[];\r\n            instructions.push(`  - First start from ${namedThread[0].name}`);\r\n            for (let iP = 1; iP < namedThread.length; iP++) {\r\n                instructions.push(`  - then go to ${namedThread[iP].name} (this is segment ${iP} / ${namedThread.length - 1})`);\r\n            }\r\n        });\r\n\r\n        return instructions.join(\"\\n\");\r\n    }\r\n\r\n    private initializeHiddenCanvasLineProperties(): void {\r\n        const theoricalThicknes = this.lineThickness * this.hiddenCanvasScale;\r\n\r\n        if (theoricalThicknes <= 1) {\r\n            // do not go below a line width of 1 because it creates artifact.\r\n            // instead, lower the lines opacity.\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity * theoricalThicknes;\r\n            this.hiddenCanvasContext.lineWidth = 1;\r\n        } else {\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity;\r\n            this.hiddenCanvasContext.lineWidth = theoricalThicknes;\r\n        }\r\n    }\r\n\r\n    private computeSegment(thread: IPeg[]): void {\r\n        let lastPeg: IPeg;\r\n        let nextPeg: IPeg;\r\n\r\n        if (thread.length === 0) {\r\n            const startingSegment = this.computeBestStartingSegment();\r\n            thread.push(startingSegment.peg1);\r\n            lastPeg = startingSegment.peg1;\r\n            nextPeg = startingSegment.peg2;\r\n        } else {\r\n            lastPeg = thread[thread.length - 1];\r\n            const HISTORY_SIZE = Math.min(thread.length, 20);\r\n            const prevousPegs = thread.slice(-HISTORY_SIZE);\r\n            nextPeg = this.computeBestNextPeg(lastPeg, prevousPegs);\r\n        }\r\n\r\n        thread.push(nextPeg);\r\n        this.drawSegmentOnHiddenCanvas(lastPeg, nextPeg);\r\n    }\r\n\r\n    private resetHiddenCanvas(): void {\r\n        const wantedSize = ThreadComputer.computeBestSize(this.sourceImage, 100 * this.hiddenCanvasScale);\r\n        this.hiddenCanvas.width = wantedSize.width;\r\n        this.hiddenCanvas.height = wantedSize.height;\r\n\r\n        resetCanvasCompositing(this.hiddenCanvasContext);\r\n        this.hiddenCanvasContext.drawImage(this.sourceImage, 0, 0, wantedSize.width, wantedSize.height);\r\n\r\n        // change the base level so that pure white becomes medium grey\r\n        const imageData = this.hiddenCanvasContext.getImageData(0, 0, wantedSize.width, wantedSize.height);\r\n        this.thread.adjustCanvasData(imageData.data, Parameters.invertColors);\r\n        this.hiddenCanvasContext.putImageData(imageData, 0, 0);\r\n        this.computeError();\r\n\r\n        this.initializeHiddenCanvasLineProperties();\r\n    }\r\n\r\n    private computeError(): void {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        this.error = {\r\n            average: 0,\r\n            variance: 0,\r\n            meanSquare: 0,\r\n        };\r\n\r\n        const nbPixels = this.hiddenCanvasData.width * this.hiddenCanvasData.height;\r\n        const nbSamples = 3 * nbPixels;\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n\r\n            this.error.average += errorRed + errorGreen + errorBlue;\r\n            this.error.meanSquare += (errorRed * errorRed) + (errorGreen * errorGreen) + (errorBlue * errorBlue);\r\n        }\r\n        this.error.average = Math.round(this.error.average / nbSamples);\r\n        this.error.meanSquare = Math.round(this.error.meanSquare / nbSamples);\r\n\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n            const error = (errorRed + errorGreen + errorBlue) / 3;\r\n            const distancetoError = error - this.error.average;\r\n            this.error.variance += distancetoError * distancetoError;\r\n        }\r\n        this.error.variance = Math.round(this.error.variance / nbSamples);\r\n    }\r\n\r\n    private computeTransformation(targetSize: ISize): Transformation {\r\n        return new Transformation(targetSize, this.hiddenCanvas);\r\n    }\r\n\r\n    private drawSegmentOnHiddenCanvas(peg1: IPeg, peg2: IPeg): void {\r\n        this.hiddenCanvasContext.beginPath();\r\n        this.hiddenCanvasContext.moveTo(peg1.x, peg1.y);\r\n        this.hiddenCanvasContext.lineTo(peg2.x, peg2.y);\r\n        this.hiddenCanvasContext.stroke();\r\n        this.hiddenCanvasContext.closePath();\r\n\r\n        // invalidate CPU data\r\n        this.hiddenCanvasData = null;\r\n    }\r\n\r\n    private computeBestStartingSegment(): ISegment {\r\n        let candidates: ISegment[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        const step = 1 + Math.floor(this.pegs.length / 100);\r\n        for (let iPegId1 = 0; iPegId1 < this.pegs.length; iPegId1 += step) {\r\n            for (let iPegId2 = iPegId1 + 1; iPegId2 < this.pegs.length; iPegId2 += step) {\r\n                const peg1 = this.pegs[iPegId1];\r\n                const peg2 = this.pegs[iPegId2];\r\n\r\n                if (!this.arePegsTooClose(peg1, peg2)) {\r\n                    const candidateScore = this.computeSegmentPotential(peg1, peg2);\r\n                    if (candidateScore > bestScore) {\r\n                        bestScore = candidateScore;\r\n                        candidates = [{ peg1, peg2, }];\r\n                    } else if (candidateScore === bestScore) {\r\n                        candidates.push({ peg1, peg2, });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private computeBestNextPeg(currentPeg: IPeg, pegsToAvoid: IPeg[]): IPeg {\r\n        let candidates: IPeg[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        for (const peg of this.pegs) {\r\n            if (!this.arePegsTooClose(currentPeg, peg) && !pegsToAvoid.includes(peg)) {\r\n                const candidateScore = this.computeSegmentPotential(currentPeg, peg);\r\n                if (candidateScore > bestScore) {\r\n                    bestScore = candidateScore;\r\n                    candidates = [peg];\r\n                } else if (candidateScore === bestScore) {\r\n                    candidates.push(peg);\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private uploadCanvasDataToCPU(): void {\r\n        if (this.hiddenCanvasData === null) {\r\n            const width = this.hiddenCanvas.width;\r\n            const height = this.hiddenCanvas.height;\r\n            this.hiddenCanvasData = this.hiddenCanvasContext.getImageData(0, 0, width, height);\r\n        }\r\n    }\r\n\r\n    /* The higher the result, the better a choice the thread is. */\r\n    private computeSegmentPotential(peg1: IPeg, peg2: IPeg): number {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        let potential = 0;\r\n\r\n        const segmentLength = distance(peg1, peg2);\r\n        const nbSamples = Math.ceil(segmentLength);\r\n        for (let iSample = 0; iSample < nbSamples; iSample++) {\r\n            const r = (iSample + 1) / (nbSamples + 1);\r\n            const sample: IPoint = {\r\n                x: mix(peg1.x, peg2.x, r),\r\n                y: mix(peg1.y, peg2.y, r),\r\n            };\r\n\r\n            const imageValue = this.sampleCanvasData(sample);\r\n            const finalValue = imageValue + (this.lineOpacityInternal * 255);\r\n            const contribution = 127 - finalValue;\r\n            potential += contribution;\r\n        }\r\n\r\n        return potential / nbSamples;\r\n    }\r\n\r\n    /** Linear interpolation. Returns a result in [0, 255] */\r\n    private sampleCanvasData(coords: IPoint): number {\r\n        const width = this.hiddenCanvasData.width;\r\n        const height = this.hiddenCanvasData.height;\r\n\r\n        const minX = clamp(Math.floor(coords.x), 0, width - 1);\r\n        const maxX = clamp(Math.ceil(coords.x), 0, width - 1);\r\n        const minY = clamp(Math.floor(coords.y), 0, height - 1);\r\n        const maxY = clamp(Math.ceil(coords.y), 0, height - 1);\r\n\r\n        const topLeft = this.sampleCanvasPixel(minX, minY);\r\n        const topRight = this.sampleCanvasPixel(maxX, minY);\r\n        const bottomLeft = this.sampleCanvasPixel(minX, maxY);\r\n        const bottomRight = this.sampleCanvasPixel(maxX, maxY);\r\n\r\n        const fractX = coords.x % 1;\r\n        const top = mix(topLeft, topRight, fractX);\r\n        const bottom = mix(bottomLeft, bottomRight, fractX);\r\n\r\n        const fractY = coords.y % 1;\r\n        return mix(top, bottom, fractY);\r\n    }\r\n\r\n    private sampleCanvasPixel(pixelX: number, pixelY: number): number {\r\n        const index = 4 * (pixelX + pixelY * this.hiddenCanvasData.width);\r\n        return this.thread.sampleCanvas(this.hiddenCanvasData.data, index);\r\n    }\r\n\r\n    private static computeBestSize(sourceImageSize: ISize, maxSize: number): ISize {\r\n        const maxSourceSide = Math.max(sourceImageSize.width, sourceImageSize.height);\r\n        const sizingFactor = maxSize / maxSourceSide;\r\n        return {\r\n            width: Math.ceil(sourceImageSize.width * sizingFactor),\r\n            height: Math.ceil(sourceImageSize.height * sizingFactor),\r\n        };\r\n    }\r\n\r\n    private computePegs(): IPeg[] {\r\n        /* First, compute pegs for a fixed-size canvas*/\r\n        let domainSize: ISize;\r\n        {\r\n            const DEFAULT_CANVAS_SIZE_FOR_PEGS = 1000;\r\n            const aspectRatio = this.hiddenCanvas.width / this.hiddenCanvas.height;\r\n            if (aspectRatio > 1) {\r\n                domainSize = { width: DEFAULT_CANVAS_SIZE_FOR_PEGS, height: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS / aspectRatio) };\r\n            } else {\r\n                domainSize = { width: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS * aspectRatio), height: DEFAULT_CANVAS_SIZE_FOR_PEGS };\r\n            }\r\n        }\r\n        const pegsShape = Parameters.shape;\r\n        const pegsSpacing = 20 * Parameters.pegsSpacing;\r\n\r\n        const pegs: IPeg[] = [];\r\n\r\n        if (pegsShape === EShape.RECTANGLE) {\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                return peg1.x === peg2.x || peg1.y === peg2.y;\r\n            };\r\n\r\n            const maxX = domainSize.width;\r\n            const maxY = domainSize.height;\r\n\r\n            const nbPegsPerWidth = Math.ceil(maxX / pegsSpacing);\r\n            const nbPegsPerHeight = Math.ceil(maxY / pegsSpacing);\r\n\r\n            pegs.push({ x: 0, y: 0 });\r\n\r\n            for (let iW = 1; iW < nbPegsPerWidth; iW++) {\r\n                pegs.push({ x: maxX * (iW / nbPegsPerWidth), y: 0 });\r\n            }\r\n\r\n            pegs.push({ x: maxX, y: 0 });\r\n\r\n            for (let iH = 1; iH < nbPegsPerHeight; iH++) {\r\n                pegs.push({ x: maxX, y: maxY * (iH / nbPegsPerHeight) });\r\n            }\r\n\r\n            pegs.push({ x: maxX, y: maxY });\r\n\r\n            for (let iW = nbPegsPerWidth - 1; iW >= 1; iW--) {\r\n                pegs.push({ x: maxX * (iW / nbPegsPerWidth), y: maxY });\r\n            }\r\n\r\n            pegs.push({ x: 0, y: maxY });\r\n\r\n            for (let iH = nbPegsPerHeight - 1; iH >= 1; iH--) {\r\n                pegs.push({ x: 0, y: maxY * (iH / nbPegsPerHeight) });\r\n            }\r\n        } else {\r\n            interface IPegCircle extends IPeg {\r\n                angle: number;\r\n            }\r\n\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                const absDeltaAngle = Math.abs((peg1 as IPegCircle).angle - (peg2 as IPegCircle).angle);\r\n                const minAngle = Math.min(absDeltaAngle, TWO_PI - absDeltaAngle);\r\n                return minAngle <= TWO_PI / 16;\r\n            };\r\n\r\n            const maxSize = Math.max(domainSize.width, domainSize.height);\r\n            const nbPegs = Math.ceil(0.5 * TWO_PI * maxSize / pegsSpacing);\r\n            const baseDeltaAngle = TWO_PI / nbPegs;\r\n            for (let iPeg = 0; iPeg < nbPegs; iPeg++) {\r\n                const angle = iPeg * baseDeltaAngle;\r\n                const peg: IPegCircle = {\r\n                    x: 0.5 * domainSize.width * (1 + Math.cos(angle)),\r\n                    y: 0.5 * domainSize.height * (1 + Math.sin(angle)),\r\n                    angle,\r\n                }\r\n                pegs.push(peg);\r\n            }\r\n        }\r\n\r\n        /* Then adjust the pegs to the actual canvas size */\r\n        for (const peg of pegs) {\r\n            peg.x *= this.hiddenCanvas.width / domainSize.width;\r\n            peg.y *= this.hiddenCanvas.height / domainSize.height;\r\n        }\r\n\r\n        return pegs;\r\n    }\r\n}\r\n\r\nexport { ThreadComputer, IPeg };\r\n","import { Parameters } from \"../parameters\";\r\nimport { IPlotterInfo, PlotterBase } from \"../plotter/plotter-base\";\r\nimport { ThreadComputer } from \"./thread-computer\";\r\n\r\nclass ThreadPlotter {\r\n    private nbSegmentsDrawn: number = 0;\r\n\r\n    public constructor(private readonly plotter: PlotterBase, private readonly threadComputer: ThreadComputer) { }\r\n\r\n    public reset(): void {\r\n        this.nbSegmentsDrawn = 0;\r\n    }\r\n\r\n    public plot(): void {\r\n        if (this.nbSegmentsDrawn === this.threadComputer.nbSegments) {\r\n            // nothing more to do\r\n            return;\r\n        } else if (this.nbSegmentsDrawn > this.threadComputer.nbSegments) {\r\n            // if the nb of segment went down, no other choice that redrawing all from scratch\r\n            this.nbSegmentsDrawn = 0;\r\n        }\r\n\r\n        const drawFromScratch = (this.nbSegmentsDrawn === 0);\r\n        if (drawFromScratch) {\r\n            const plotterInfos: IPlotterInfo = {\r\n                backgroundColor: Parameters.invertColors ? \"black\" : \"white\",\r\n                blur: Parameters.blur,\r\n            };\r\n\r\n            this.plotter.resize();\r\n            this.plotter.initialize(plotterInfos);\r\n\r\n            if (Parameters.displayPegs) {\r\n                this.threadComputer.drawPegs(this.plotter);\r\n            }\r\n\r\n            this.threadComputer.drawThread(this.plotter, 0);\r\n            this.plotter.finalize();\r\n        } else {\r\n            this.threadComputer.drawThread(this.plotter, this.nbSegmentsDrawn);\r\n        }\r\n\r\n        this.nbSegmentsDrawn = this.threadComputer.nbSegments;\r\n    }\r\n}\r\n\r\nexport { ThreadPlotter };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\ntype ThreadsIterator = (thread: IPeg[], color: EColor) => unknown;\r\n\r\ntype SamplingFunction = (data: Uint8ClampedArray, index: number) => number;\r\n\r\ninterface IThreadToGrow {\r\n    thread: IPeg[];\r\n    color: EColor;\r\n}\r\n\r\nabstract class ThreadBase {\r\n    public abstract get totalNbSegments(): number;\r\n\r\n    public abstract lowerNbSegments(targetNumber: number): void;\r\n\r\n    public abstract iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void;\r\n\r\n    public abstract getThreadToGrow(): IThreadToGrow;\r\n\r\n    public abstract adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void;\r\n\r\n    public abstract enableSamplingFor(color: EColor): void;\r\n\r\n    /**\r\n     * @returns value in [0, 255]. Ideal value is 127\r\n     */\r\n    public sampleCanvas: SamplingFunction = null;\r\n\r\n    protected static lowerNbSegmentsForThread(thread: IPeg[], targetNumber: number): void {\r\n        if (targetNumber > 0) {\r\n            thread.length = Math.min(thread.length, targetNumber + 1);\r\n        } else {\r\n            thread.length = 0;\r\n        }\r\n    }\r\n\r\n    protected static computeNbSegments(thread: IPeg[]): number {\r\n        return (thread.length > 1) ? thread.length - 1 : 0;\r\n    }\r\n\r\n    public static iterateOnThread(thread: IPeg[], color: EColor, fromSegmentNumber: number, callback: ThreadsIterator): void {\r\n        const threadLength = ThreadBase.computeNbSegments(thread);\r\n        if (fromSegmentNumber < threadLength) {\r\n            const threadPart = thread.slice(fromSegmentNumber);\r\n            callback(threadPart, color);\r\n        }\r\n    }\r\n}\r\n\r\nexport {\r\n    IThreadToGrow,\r\n    ThreadBase,\r\n    ThreadsIterator,\r\n};\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\nclass ThreadMonochrome extends ThreadBase {\r\n    private threadPegs: IPeg[] = [];\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegs);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegs, targetNumber);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        ThreadBase.iterateOnThread(this.threadPegs, EColor.MONOCHROME, nbSegmentsToIgnore, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        return {\r\n            thread: this.threadPegs,\r\n            color: EColor.MONOCHROME,\r\n        }\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            const averageSourceValue = (data[4 * i + 0] + data[4 * i + 1] + data[4 * i + 2]) / 3;\r\n            const adjustedValue = computeAdjustedValue(averageSourceValue);\r\n            data[4 * i + 0] = adjustedValue;\r\n            data[4 * i + 1] = adjustedValue;\r\n            data[4 * i + 2] = adjustedValue;\r\n        }\r\n    }\r\n\r\n    public enableSamplingFor(): void {\r\n        if (this.sampleCanvas === null) {\r\n            this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n                return data[index + 0]; // only check the red channel because the hidden canvas is in black and white\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport { ThreadMonochrome };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\ninterface ISegmentsRepartition {\r\n    red: number;\r\n    green: number;\r\n    blue: number;\r\n}\r\n\r\nclass ThreadRedBlueGreen extends ThreadBase {\r\n    private threadPegsRed: IPeg[] = [];\r\n    private threadPegsGreen: IPeg[] = [];\r\n    private threadPegsBlue: IPeg[] = [];\r\n\r\n    // indicators describing the colors repartition from the source image\r\n    private frequencyRed: number;\r\n    private frequencyGreen: number;\r\n    private frequencyBlue: number;\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegsRed) +\r\n            ThreadBase.computeNbSegments(this.threadPegsGreen) +\r\n            ThreadBase.computeNbSegments(this.threadPegsBlue);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(targetNumber);\r\n\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsRed, repartition.red);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsGreen, repartition.green);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsBlue, repartition.blue);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(nbSegmentsToIgnore);\r\n\r\n        ThreadBase.iterateOnThread(this.threadPegsRed, EColor.RED, repartition.red, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsGreen, EColor.GREEN, repartition.green, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsBlue, EColor.BLUE, repartition.blue, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        const repartition = this.computeIdealSegmentsRepartition(this.totalNbSegments + 1);\r\n        if (repartition.red > 0 && this.threadPegsRed.length < repartition.red + 1) {\r\n            return {\r\n                thread: this.threadPegsRed,\r\n                color: EColor.RED,\r\n            };\r\n        } else if (repartition.green > 0 && this.threadPegsGreen.length < repartition.green + 1) {\r\n            return {\r\n                thread: this.threadPegsGreen,\r\n                color: EColor.GREEN,\r\n            };\r\n        }\r\n\r\n        return {\r\n            thread: this.threadPegsBlue,\r\n            color: EColor.BLUE,\r\n        };\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let cumulatedRed = 0;\r\n        let cumulatedGreen = 0;\r\n        let cumulatedBlue = 0;\r\n\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            cumulatedRed += data[4 * i + 0];\r\n            cumulatedGreen += data[4 * i + 1];\r\n            cumulatedBlue += data[4 * i + 2];\r\n\r\n            data[4 * i + 0] = computeAdjustedValue(data[4 * i + 0]);\r\n            data[4 * i + 1] = computeAdjustedValue(data[4 * i + 1]);\r\n            data[4 * i + 2] = computeAdjustedValue(data[4 * i + 2]);\r\n        }\r\n\r\n        if (!blackBackground) {\r\n            cumulatedRed = 255 * nbPixels - cumulatedRed;\r\n            cumulatedGreen = 255 * nbPixels - cumulatedGreen;\r\n            cumulatedBlue = 255 * nbPixels - cumulatedBlue;\r\n        }\r\n\r\n        const totalColor = cumulatedRed + cumulatedGreen + cumulatedBlue;\r\n        this.frequencyRed = cumulatedRed / totalColor;\r\n        this.frequencyGreen = cumulatedGreen / totalColor;\r\n        this.frequencyBlue = cumulatedBlue / totalColor;\r\n    }\r\n\r\n    public enableSamplingFor(color: EColor): void {\r\n        let channel: number;\r\n        if (color === EColor.RED) {\r\n            channel = 0;\r\n        } else if (color === EColor.GREEN) {\r\n            channel = 1;\r\n        } else {\r\n            channel = 2;\r\n        }\r\n\r\n        this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n            return data[index + channel];\r\n        }\r\n    }\r\n\r\n    private computeIdealSegmentsRepartition(totalNbSegments: number): ISegmentsRepartition {\r\n        const idealRed = totalNbSegments * this.frequencyRed;\r\n        const idealGreen = totalNbSegments * this.frequencyGreen;\r\n        const idealBlue = totalNbSegments * this.frequencyBlue;\r\n\r\n        const repartition = {\r\n            red: Math.floor(idealRed),\r\n            green: Math.floor(idealGreen),\r\n            blue: Math.floor(idealBlue),\r\n        };\r\n\r\n        while (repartition.red + repartition.green + repartition.blue < totalNbSegments) {\r\n            const currentFrequencyRed = repartition.red / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyGreen = repartition.green / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyBlue = repartition.blue / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n\r\n            const gapRed = idealRed - currentFrequencyRed;\r\n            const gapGreen = idealGreen - currentFrequencyGreen;\r\n            const gapBlue = idealBlue - currentFrequencyBlue;\r\n\r\n            if (gapRed > gapGreen && gapRed > gapBlue) {\r\n                repartition.red++;\r\n            } else if (gapGreen > gapRed && gapGreen > gapBlue) {\r\n                repartition.green++;\r\n            } else {\r\n                repartition.blue++;\r\n            }\r\n        }\r\n\r\n        return repartition;\r\n    }\r\n}\r\n\r\nexport { ThreadRedBlueGreen };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\nclass Transformation {\r\n    public readonly scaling: number;\r\n    public readonly origin: IPoint;\r\n\r\n    public constructor(frameSize: ISize, elementSize: ISize) {\r\n        const scaleToFitWidth = frameSize.width / elementSize.width;\r\n        const scaleToFitHeight = frameSize.height / elementSize.height;\r\n\r\n        this.scaling = Math.min(scaleToFitWidth, scaleToFitHeight);\r\n        this.origin = {\r\n            x: 0.5 * (frameSize.width - this.scaling * elementSize.width),\r\n            y: 0.5 * (frameSize.height - this.scaling * elementSize.height)\r\n        };\r\n    }\r\n\r\n    public transform(point: IPoint): IPoint {\r\n        return {\r\n            x: this.origin.x + point.x * this.scaling,\r\n            y: this.origin.y + point.y * this.scaling,\r\n        };\r\n    }\r\n}\r\n\r\nexport { Transformation };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(633);\n"],"sourceRoot":""}